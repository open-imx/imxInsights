from dataclasses import dataclass
from enum import Enum
from pathlib import Path

from loguru import logger
from lxml import etree
from lxml.etree import _Element as Element

from imxInsights.utils.file import get_http_content_type, zip_folder
from imxInsights.utils.hash import hash_sha256


class FileType(Enum):
    CORE = "core"
    PETAL = "petal"
    MEDIA = "media"


@dataclass
class ManifestFile:
    """
    Represents a file entry in the manifest, containing metadata.

    Attributes:
        file: Path to the file.
        hash: SHA-256 hash of the file.
        file_type: Type of file.
        parent_document_name: Name of the parent document (if applicable).
        parent_hash_code: Hash of the parent document (if applicable).
        full_path_as_filename: Optionally stores the relative path from input folder.
    """

    file: Path
    hash: str
    file_type: FileType
    parent_document_name: str | None = None
    parent_hash_code: str | None = None
    full_path_as_filename: bool = False  # Flag to toggle full path in filename

    def get_filename(self, input_folder: Path):
        """Returns the file name or relative path from input folder as the filename."""
        if self.full_path_as_filename:
            return str(
                self.file.relative_to(input_folder)
            )  # Get relative path from input_folder
        return self.file.name  # Just return the file name


class ManifestBuilder:
    """
    Generate an XML manifest file from the contents of a folder.

    The manifest categorizes files into three types:

    1. **Core Files**
       - The primary IM Spoor file, identified by the root tag `<SignalingDesign>`.
       - Only one core file should exist.

    2. **Petal Files**
       - Supporting XML files that reference the core file.
       - Identified by specific root tags such as `<Bgt>`, `<Furniture>`, etc.
       - Must contain a `<BaseReference>` element linking to the core file via `parentDocumentName` and `parentHashcode`.
       - If a petal file references a mismatched core file or hash, a comment is added:
         - `"Invalid CoreFile reference"` (if `parentDocumentName` doesn’t match).
         - `"Invalid ParentHashCode"` (if `parentHashcode` doesn’t match).

    2b. **Including Old Core or Petal Files**
       - Old core or petal files can be added as media files by appending `-old.xml` to the filename.

    3. **Media Files**
       - Non-XML files (e.g., images, PDFs, other binary formats).
       - Included under the `<MediaList>` section.

    Additional Comments in the Manifest:
    - A warning is added if a petal file's `parentDocumentName` does not match the core file.
    - A comment is included if a petal file’s `parentHashcode` differs from the core file’s hash.

    Args:
        folder_path (str): Path to the folder containing IM Spoor files.
    """

    NAMESPACE = "http://www.prorail.nl/IMSpoor"
    SCHEMA_LOCATION = "http://www.prorail.nl/IMSpoor IMSpoor-Manifest.xsd"

    def __init__(self, folder_path: Path | str):
        self.folder_path = Path(folder_path)

    def _create_manifest_root(self) -> Element:
        """Creates root XML element for the manifest."""
        nsmap = {
            None: self.NAMESPACE,
            "xsi": "http://www.w3.org/2001/XMLSchema-instance",
        }
        manifest = etree.Element(
            "Manifest",
            attrib={
                "imxVersion": "12.0.0",
                "coreFileName": "to_fill",
                "nidRbc": "to_fill",
                "nidC": "to_fill",
                "{http://www.w3.org/2001/XMLSchema-instance}schemaLocation": self.SCHEMA_LOCATION,
            },
            nsmap=nsmap,
        )
        manifest.append(etree.Comment("IMX 12 manifest generated by imxInsights."))
        manifest.append(etree.Comment("Manifest marked as 'FOR TEST PURPOSES'!"))
        return manifest

    def _parse_xml(self, file: Path) -> str | None:
        """Parses XML and extracts the root tag safely."""
        try:
            return str(etree.parse(file).getroot().tag)
        except etree.XMLSyntaxError:
            logger.error(f"Invalid XML: {file}")
            return None

    def _list_folder_content(
        self,
    ) -> tuple[list[ManifestFile], str | None, Path | None]:
        """Scans folder for XML and media files, determining core file and petal dependencies."""
        core_file_tag = f"{{{self.NAMESPACE}}}SignalingDesign"
        petal_tags = {
            f"{{{self.NAMESPACE}}}{tag}"
            for tag in [
                "Bgt",
                "Furniture",
                "Legacy",
                "InstallationDesign",
                "ManagementAreas",
                "NetworkConfiguration",
                "Observations",
                "RailwayElectrification",
                "SchemaLayout",
                "TrainControl",
                "Extensions",
            ]
        }
        manifest_tag = f"{{{self.NAMESPACE}}}Manifest"
        files = []
        core_file, core_hash = None, None

        def crawl_directory(directory: Path):
            """Recursively crawl through all directories and treat nested files as media."""
            nonlocal files, core_file, core_hash

            for file in directory.iterdir():
                if file.is_dir():
                    # If it's a directory, treat all files inside as media
                    crawl_directory(file)  # Recurse into subdirectories
                    continue

                file_hash = hash_sha256(file)
                file_type, parent_name, parent_hash = FileType.MEDIA, None, None

                if file.suffix.lower() == ".xml":
                    root_tag = self._parse_xml(file)

                    if root_tag:
                        if manifest_tag == root_tag:
                            continue
                        elif root_tag == core_file_tag:
                            core_file, core_hash = file, file_hash
                            file_type = FileType.CORE
                        elif root_tag in petal_tags:
                            tree = etree.parse(file)
                            base_ref = tree.find(f"*{{{self.NAMESPACE}}}BaseReference")
                            parent_name = (
                                base_ref.get("parentDocumentName")
                                if base_ref is not None and len(base_ref) == 1
                                else None
                            )
                            parent_hash = (
                                base_ref.get("parentHashcode")
                                if base_ref is not None and len(base_ref) == 1
                                else None
                            )
                            file_type = FileType.PETAL

                files.append(
                    ManifestFile(
                        file,
                        file_hash,
                        file_type,
                        parent_name,
                        parent_hash,
                        full_path_as_filename=True,
                    )
                )

        # Start crawling the folder
        crawl_directory(self.folder_path)

        return files, core_hash, core_file

    def create_manifest(self, file_path: Path | str | None = None) -> None:
        """
        Generates an XML manifest file containing metadata for IM Spoor files.

        Args:
            file_path: Output path for the manifest XML file, if not given will be generated in input folder.
        """
        manifest = self._create_manifest_root()
        file_list, core_hash, core_file = self._list_folder_content()

        if core_file:
            manifest.set("coreFileName", core_file.name)

        im_spoor_list = etree.SubElement(manifest, "ImSpoorDataList")
        media_list = etree.SubElement(manifest, "MediaList")

        for item in file_list:
            attributes = {
                "fileName": item.get_filename(
                    self.folder_path
                ),  # Use relative path or filename
                "mediaType": get_http_content_type(item.file.name),
                "hash": item.hash,
            }

            if (
                item.file_type in {FileType.CORE, FileType.PETAL}
                and "-old" not in item.file.name
            ):
                petal_element = etree.SubElement(
                    im_spoor_list, "ImSpoorData", attrib=attributes
                )
                if item.file_type != FileType.CORE:
                    if item.parent_document_name != (
                        core_file.name if core_file else None
                    ):
                        petal_element.append(
                            etree.Comment("Invalid CoreFile reference.")
                        )
                    if item.parent_hash_code != core_hash:
                        petal_element.append(etree.Comment("Invalid ParentHashCode."))
            else:
                etree.SubElement(media_list, "Media", attrib=attributes)

        output_path = (
            Path(file_path) if file_path else self.folder_path / "Manifest.xml"
        )
        with output_path.open("wb") as f:
            f.write(
                etree.tostring(
                    manifest, pretty_print=True, xml_declaration=True, encoding="UTF-8"
                )
            )

        logger.success(f"Manifest created: {output_path}")

    def to_zip(self, out_path: Path | str) -> None:
        """
        Generates an .zip file of the input_folder.

        Args:
            out_path: Output path for the manifest XML file.
        """
        zip_folder(self.folder_path, Path(out_path))
